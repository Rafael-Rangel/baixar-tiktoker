"""
Serviço de download usando Selenium (Chrome headless) como fallback
Usado quando yt-dlp falha devido a detecção de bot do YouTube
"""
import os
import logging
import time
from typing import Optional
from selenium import webdriver
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.common.exceptions import TimeoutException, WebDriverException
from webdriver_manager.chrome import ChromeDriverManager
import yt_dlp

logger = logging.getLogger(__name__)


class SeleniumDownloaderService:
    """Serviço para download usando navegador real (Chrome headless)"""
    
    def __init__(self):
        """Inicializa serviço stateless"""
        self.driver = None
    
    def _get_chrome_options(self) -> Options:
        """Configura opções do Chrome para modo headless"""
        options = Options()
        options.add_argument("--headless=new")  # Novo modo headless do Chrome
        options.add_argument("--no-sandbox")
        options.add_argument("--disable-dev-shm-usage")
        options.add_argument("--disable-gpu")
        options.add_argument("--disable-extensions")
        options.add_argument("--disable-software-rasterizer")
        options.add_argument("--disable-blink-features=AutomationControlled")
        options.add_experimental_option("excludeSwitches", ["enable-automation"])
        options.add_experimental_option('useAutomationExtension', False)
        options.add_argument("--user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36")
        return options
    
    def _init_driver(self) -> webdriver.Chrome:
        """Inicializa driver do Chrome"""
        try:
            options = self._get_chrome_options()
            service = Service(ChromeDriverManager().install())
            driver = webdriver.Chrome(service=service, options=options)
            # Remover indicadores de automação
            driver.execute_cdp_cmd('Page.addScriptToEvaluateOnNewDocument', {
                'source': '''
                    Object.defineProperty(navigator, 'webdriver', {
                        get: () => undefined
                    })
                '''
            })
            return driver
        except Exception as e:
            logger.error(f"Failed to initialize Chrome driver: {e}")
            raise
    
    def _extract_cookies_from_browser(self, video_url: str) -> Optional[str]:
        """Extrai cookies do navegador após navegar até o vídeo"""
        try:
            self.driver = self._init_driver()
            logger.info(f"Selenium: Navigating to {video_url}")
            
            # Navegar até o vídeo
            self.driver.get(video_url)
            
            # Aguardar página carregar (aguardar elemento de vídeo aparecer)
            try:
                WebDriverWait(self.driver, 15).until(
                    EC.presence_of_element_located((By.TAG_NAME, "video"))
                )
                logger.info("Selenium: Video element found, page loaded")
            except TimeoutException:
                logger.warning("Selenium: Video element not found, but continuing...")
            
            # Aguardar um pouco mais para garantir que cookies estão atualizados
            import time
            time.sleep(3)
            
            # Extrair cookies do navegador
            cookies = self.driver.get_cookies()
            
            # Criar arquivo temporário de cookies no formato Netscape
            import tempfile
            temp_cookies_file = tempfile.NamedTemporaryFile(mode='w', suffix='.txt', delete=False)
            
            # Escrever header do formato Netscape
            temp_cookies_file.write("# Netscape HTTP Cookie File\n")
            temp_cookies_file.write("# This file is generated by Selenium. Do not edit.\n\n")
            
            # Escrever cookies
            for cookie in cookies:
                domain = cookie.get('domain', '')
                if not domain.startswith('.'):
                    domain = '.' + domain
                
                # Formato Netscape: domain, flag, path, secure, expiration, name, value
                secure = 'TRUE' if cookie.get('secure', False) else 'FALSE'
                expiration = str(int(cookie.get('expiry', 0))) if cookie.get('expiry') else '0'
                path = cookie.get('path', '/')
                
                line = f"{domain}\tTRUE\t{path}\t{secure}\t{expiration}\t{cookie['name']}\t{cookie['value']}\n"
                temp_cookies_file.write(line)
            
            temp_cookies_file.close()
            logger.info(f"Selenium: Extracted {len(cookies)} cookies to {temp_cookies_file.name}")
            
            return temp_cookies_file.name
            
        except Exception as e:
            logger.error(f"Selenium: Failed to extract cookies: {e}")
            return None
        finally:
            if self.driver:
                try:
                    self.driver.quit()
                except:
                    pass
                self.driver = None
    
    async def download_video(
        self,
        video_url: str,
        output_path: str,
        external_video_id: Optional[str] = None
    ) -> dict:
        """
        Faz download usando Selenium como fallback
        Estratégia: Extrai cookies do navegador e usa com yt-dlp
        """
        cookies_file = None
        try:
            logger.info(f"Selenium: Starting download fallback for {external_video_id or video_url}")
            
            # Extrair cookies do navegador (executar em thread separada para não bloquear)
            import asyncio
            loop = asyncio.get_event_loop()
            cookies_file = await loop.run_in_executor(None, self._extract_cookies_from_browser, video_url)
            
            if not cookies_file:
                return {"status": "failed", "error": "Failed to extract cookies from browser"}
            
            # Tentar download com yt-dlp usando cookies do navegador
            logger.info("Selenium: Attempting download with yt-dlp using browser cookies")
            
            output_path_abs = os.path.abspath(output_path)
            ydl_opts = {
                "cookiefile": cookies_file,
                "outtmpl": output_path_abs.replace(".mp4", ".%(ext)s"),
                "format": "bestvideo+bestaudio/best",
                "merge_output_format": "mp4",
                "quiet": True,
                "no_warnings": True,
                "noplaylist": True,
                "extractor_args": {
                    "youtube": {
                        "player_client": ["mweb", "ios", "android", "web"]
                    }
                },
                "referer": "https://www.youtube.com/",
                "user_agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
            }
            
            with yt_dlp.YoutubeDL(ydl_opts) as ydl:
                ydl.download([video_url])
            
            # Verificar se arquivo foi criado
            if os.path.exists(output_path_abs) and os.path.getsize(output_path_abs) > 1000:
                logger.info(f"Selenium: Download successful! File size: {os.path.getsize(output_path_abs)} bytes")
                return {"status": "completed", "path": output_path_abs}
            
            # Tentar outros formatos/extensões
            base = output_path_abs.replace(".mp4", "")
            for ext in [".webm", ".mkv", ".m4a"]:
                p = base + ext
                if os.path.exists(p) and os.path.getsize(p) > 1000:
                    if ext != ".mp4":
                        os.rename(p, output_path_abs)
                    logger.info(f"Selenium: Download successful! File size: {os.path.getsize(output_path_abs)} bytes")
                    return {"status": "completed", "path": output_path_abs}
            
            return {"status": "failed", "error": "Download completed but file not found or too small"}
            
        except Exception as e:
            logger.error(f"Selenium: Download failed: {e}")
            return {"status": "failed", "error": f"Selenium download failed: {str(e)}"}
        finally:
            # Limpar arquivo temporário de cookies
            if cookies_file and os.path.exists(cookies_file):
                try:
                    os.unlink(cookies_file)
                except:
                    pass
            
            # Garantir que driver está fechado
            if self.driver:
                try:
                    self.driver.quit()
                except:
                    pass
                self.driver = None
